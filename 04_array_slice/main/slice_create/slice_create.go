package main

import "fmt"

/*
切片（slice）是对数组一个连续片段的引用（该数组我们称之为相关数组，通常是匿名的），所以切片是一个引用类型（因此更类似于 C/C++ 中的数组类型，或者 Python 中的 list 类型）。这个片段可以是整个数组，或者是由起始和终止索引标识的一些项的子集。需要注意的是，终止索引标识的项不包括在切片内。切片提供了一个相关数组的动态窗口。

切片是可索引的，并且可以由 len() 函数获取长度

给定项的切片索引可能比相关数组的相同元素的索引小。和数组不同的是，切片的长度可以在运行时修改，最小为 0 最大为相关数组的长度：切片是一个 长度可变的数组

切片的长度永远不会超过它的容量，所以对于 切片 s 来说该不等式永远成立：0 <= len(s) <= cap(s)

优点 因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中 切片比数组更常用。

*/
func main() {
	// 一个切片在未初始化之前默认为 nil，长度为 0
	arr := [5]int{1, 2, 3, 4, 5}
	// 多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。
	s1 := arr[:3]
	s2 := arr[:3]

	s1[1] = 100
	s2[2] = 200
	// 切片在内存中的组织方式实际上是一个有 3 个域的结构体：指向相关数组的指针，切片长度以及切片容量
	s2 = s2[1:]
	fmt.Printf("arr: %v\n", arr)
	fmt.Printf("s1: %v\n", s1)
	fmt.Printf("s2: %v\n", s2)
	// 绝对不要用指针指向 slice。切片本身已经是一个引用类型，所以它本身就是一个指针！！

	/*
	arr: [1 100 200 4 5]
	s1: [1 100 200]
	s2: [1 100 200]
	*/

	
}
