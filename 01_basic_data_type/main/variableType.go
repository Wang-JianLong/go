package main

import "fmt"

// 根据不同的处理器以及操作系统类型，所有的字都具有 32 位（4 字节）或 64 位（8 字节）的相同长度；所有的字都使用相关的内存地址来进行表示（以十六进制数表示）
// 所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：
// 像数组（第 7 章）和结构（第 10 章）这些复合类型也是值类型
func main() {
	// 当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝：

	// 使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明
	// 声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误 全局变量是允许声明但不使用。
	i := 7
	j := i
	// 可以通过 &i 来获取变量 i 的内存地址 值类型的变量的值存储在栈中。
	fmt.Println(&j) //0xc000010098

	// 更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。

	// 这个内存地址被称之为指针 当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。

	// 如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。

	// 在 Go 语言中，指针属于引用类型，其它的引用类型还包括 slices，maps和 channel。被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。

	// a, b, c := 5, 7, "abc" 这被称为 并行 或 同时 赋值
	// 如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a

	// 空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。
	//_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值

}

/*
变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高

每个源文件都只能包含一个(???) init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。

一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。

init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine
*/
func init(){
	fmt.Println("init...")
	// go backend();
}

func init(){
	fmt.Println("init3...")
	// go backend();
}