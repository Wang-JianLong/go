package main

import (
	"fmt"
	"math"
)

// 基本类型以及运算符
func main() {
	/*
				只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface），它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。

						Go 也有基于架构的类型，例如：int、uint 和 uintptr。

				这些类型的长度都是根据运行程序所在的操作系统类型所决定的：

				int 和 uint 在 32 位操作系统上，它们均使用 32 位（4 个字节），在 64 位操作系统上，它们均使用 64 位（8 个字节）。
				uintptr 的长度被设定为足够存放一个指针即可

				float32 精确到小数点后 7 位，float64 精确到小数点后 15 位
				尽可能地使用 float64，因为 math 包中所有有关数学运算的函数都会要求接收这个类型

				可以通过增加前缀 0 来表示 8 进制数（如：077），增加前缀 0x 来表示 16 进制数（如：0xFF），以及使用 e 来表示 10 的连乘（如： 1e3 = 1000

				你可以使用 a := uint64(0) 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64

				Go 中不允许不同类型之间的混合使用，但是对于常量的类型限制非常少，因此允许常量之间的混合使用


				当进行类似 a32bitInt = int32(a32Float) 的转换时，小数点后的数字将被丢弃


				Go拥有复数类型

				complex64 (32 位实数和虚数)
				complex128 (64 位实数和虚数)

				复数使用 re+imI 来表示，其中 re 代表实数部分，im 代表虚数部分，I 代表根号负 1


				按位异或 ^

				位清除 &^：将指定位置上的值设置为 0。



				严格来说，这并不是 Go 语言的一个类型，字符只是整数的特殊用例。byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题。例如：var ch byte = 'A'；字符使用单引号括起来

				=======================================================================
				
				
				（\x 总是紧跟着长度为 2 的 16 进制数）

				另外一种可能的写法是 \ 后面紧跟着长度为 3 的八进制数，例如：\377。

				不过 Go 同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。其实 rune 也是 Go 当中的一个类型，并且是 int32 的别名。

				在书写 Unicode 字符时，需要在 16 进制数之前加上前缀 \u 或者 \U。

				因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则会加上 \U 前缀；前缀 \u 则总是紧跟着长度为 4 的 16 进制数，前缀 \U 紧跟着长度为 8 的 16 进制数。
	*/

}

// 如何安全地从 int 型转换为 int8
func Uint8FromInt(n int) (uint8, error) {
	if 0 <= n && n <= math.MaxUint8 { // conversion is safe
		return uint8(n), nil
	}
	return 0, fmt.Errorf("%d is out of the uint8 range", n)
}
